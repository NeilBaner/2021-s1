{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unix 101: The NUS SoC Unix@Home Workshop AY20/21 Semester 1 About The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom. Objectives The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications Time and Venue There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom. Registration First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. lease register here. before 28 July, 2020 . License The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"Home"},{"location":"#unix-101-the-nus-soc-unixhome-workshop","text":"","title":"Unix 101: The NUS SoC Unix@Home Workshop"},{"location":"#ay2021-semester-1","text":"","title":"AY20/21 Semester 1"},{"location":"#about","text":"The NUS SoC Unix Workshop is a workshop organized by faculty members of the School of Computing, National University of Singapore, for first-year students. This year, we will conduct the \"Unix@Home\" version, entirely online via Zoom.","title":"About"},{"location":"#objectives","text":"The aims of the workshop are To introduce students to using Unix-based computing environment for daily computing tasks To prepare students to be efficient in using Unix for their computing career After taking the workshop, students are expected to: Understand common terminology: Unix, Linux, Ubuntu, SunOS, ssh, host, command line, shell, operating systems, etc. Appreciate the advantages of the Unix environment Understand the Unix file organization Able to perform common file management tasks (create/copy/move/remove/change permission, etc) through Unix shell (For Windows 10 users) Setup local Unix environment Setup apt (Win10) or Homebrew (macOS) and able to use it to install library or applications","title":"Objectives"},{"location":"#time-and-venue","text":"There will be two versions of the workshop, one for macOS users, the other for Windows 10 users. The date and time are as follows: 3-4 August , 2020 (Mon - Tue), 9:00 to 11:30 am each day. for macOS users only 6-7 August , 2020 (Thu - Fri), 9:00 to 11:30 am each day. for Windows 10 users only The workshop will be conducted online via Zoom.","title":"Time and Venue"},{"location":"#registration","text":"First-year students taking CS1010, CS2030, CS2030S, and CS2040 in Semester 1 of AY2020/21 will be given priority to register for and to attend the workshop. The workshop is sponsored by the NUS School of Computing and is free to attend. Space, however, is limited -- please register only if you are committed to attending. lease register here. before 28 July, 2020 .","title":"Registration"},{"location":"#license","text":"The content of this site is licensed under the Creative Common Attribution-NonCommercial-ShareAlike 4.0 International license","title":"License"},{"location":"mac/","text":"Setting Up Unix Computing Environment on macOS macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter . Install Command Line Development Tool Run xcode-select --install to install a set of command-line tools used for software development in macOS. Install Homebrew Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Setup for macOS"},{"location":"mac/#setting-up-unix-computing-environment-on-macos","text":"macOS is a Unix-based operating system. Not setup is required. To access the Unix command line interface, hit F4 to access LaunchPad, and type Terminal followed by Enter .","title":"Setting Up Unix Computing Environment on macOS"},{"location":"mac/#install-command-line-development-tool","text":"Run xcode-select --install to install a set of command-line tools used for software development in macOS.","title":"Install Command Line Development Tool"},{"location":"mac/#install-homebrew","text":"Homebrew is a command-line software manager for macOS. If you have not installed Homebrew before, paste the following into your shell to install it. /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \"","title":"Install Homebrew"},{"location":"schedule/","text":"Tentative Schedule for Unix@Home Workshop (Note: Allocated time is a very rough approxmiate) Day 1 Plenary Session 1: Introduction (20 minutes) What is Unix? Why are we learning/using Unix? What is CLI? Why are we learning/using CLI? What is a terminal? What is a shell? Breakout Session 2: Basic Unix Files Operations I (30 minutes) Install WSL and Windows Terminal Installing tmate for terminal sharing File Organization Root directory Home directory Looking inside a directory ( ls ) Directory tree Navigating around the directory tree ( cd ) Shortcut: . ~ , .. Bash shortcut (tab, up arrow) Referring to manuals ( man ) Break (20 minutes) Breakout Session 3: Basic Unix Files Operations II (20 minutes) Making and removing your own directory ( mkdir and rm ) Creating, moving, and copying files ( touch , mv , cp ) Looking inside a file ( cat , more , less ) File permissions ( chmod ) Break (20 minutes) Breakout Session 4: Composition (30 minutes) Standard output and standard input Redirection ( < , > , >> ) Piping ( | ) Pattern matching in bash ( * , ? , {} ) Unix power tools: Looking for something in a file ( grep ) Comparing two files ( diff ) Counting lines, words, and characters ( wc ) DAY 2 Plenary Session 5: Gaining Efficiency with Unix (10 minutes) Automation, Staying in Your Zone, and Powertools The philosophy and power of vim Breakout Session 5: Simple file editing with vim (30 minutes) Running and quitting vim Insert mode and command mode (i and esc) Moving cursor around with hjkl Break (20 minutes) Breakout Session 6: Very Basic Shell Scripts (30 minutes) Putting a sequence of commands in a file and executing the file Command-line arguments and variables Break (20 minutes) Breakout Session 7: Extending your Unix Environment (20 minutes) Using apt (WSL) and brew (macOS), curl install, list, search, uninstall Breakout Session 8: Remote Servers (10 minutes) Concepts of hosts, client, server. Accessing a remote server via ssh Ssh into sdf.org Preview of SoC Unix environments ( stu0 ) Break (20 minutes) Plenary Session 9: Conclusion and The Unix Philosophy (15 minutes) The Unix Philosophy Do one thing well Use simple text file Make every program a filter and make them work together Avoid unnecessary output","title":"Schedule"},{"location":"schedule/#tentative-schedule-for-unixhome-workshop","text":"(Note: Allocated time is a very rough approxmiate)","title":"Tentative Schedule for Unix@Home Workshop"},{"location":"schedule/#day-1","text":"","title":"Day 1"},{"location":"schedule/#plenary-session-1-introduction-20-minutes","text":"What is Unix? Why are we learning/using Unix? What is CLI? Why are we learning/using CLI? What is a terminal? What is a shell?","title":"Plenary Session 1: Introduction (20 minutes)"},{"location":"schedule/#breakout-session-2-basic-unix-files-operations-i-30-minutes","text":"Install WSL and Windows Terminal Installing tmate for terminal sharing File Organization Root directory Home directory Looking inside a directory ( ls ) Directory tree Navigating around the directory tree ( cd ) Shortcut: . ~ , .. Bash shortcut (tab, up arrow) Referring to manuals ( man )","title":"Breakout Session 2: Basic Unix Files Operations I (30 minutes)"},{"location":"schedule/#break-20-minutes","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-3-basic-unix-files-operations-ii-20-minutes","text":"Making and removing your own directory ( mkdir and rm ) Creating, moving, and copying files ( touch , mv , cp ) Looking inside a file ( cat , more , less ) File permissions ( chmod )","title":"Breakout Session 3:  Basic Unix Files Operations II (20 minutes)"},{"location":"schedule/#break-20-minutes_1","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-4-composition-30-minutes","text":"Standard output and standard input Redirection ( < , > , >> ) Piping ( | ) Pattern matching in bash ( * , ? , {} ) Unix power tools: Looking for something in a file ( grep ) Comparing two files ( diff ) Counting lines, words, and characters ( wc )","title":"Breakout Session 4: Composition (30 minutes)"},{"location":"schedule/#day-2","text":"","title":"DAY 2"},{"location":"schedule/#plenary-session-5-gaining-efficiency-with-unix-10-minutes","text":"Automation, Staying in Your Zone, and Powertools The philosophy and power of vim","title":"Plenary Session 5: Gaining Efficiency with Unix (10 minutes)"},{"location":"schedule/#breakout-session-5-simple-file-editing-with-vim-30-minutes","text":"Running and quitting vim Insert mode and command mode (i and esc) Moving cursor around with hjkl","title":"Breakout Session 5: Simple file editing with vim (30 minutes)"},{"location":"schedule/#break-20-minutes_2","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-6-very-basic-shell-scripts-30-minutes","text":"Putting a sequence of commands in a file and executing the file Command-line arguments and variables","title":"Breakout Session 6: Very Basic Shell Scripts (30 minutes)"},{"location":"schedule/#break-20-minutes_3","text":"","title":"Break (20 minutes)"},{"location":"schedule/#breakout-session-7-extending-your-unix-environment-20-minutes","text":"Using apt (WSL) and brew (macOS), curl install, list, search, uninstall","title":"Breakout Session 7: Extending your Unix Environment (20 minutes)"},{"location":"schedule/#breakout-session-8-remote-servers-10-minutes","text":"Concepts of hosts, client, server. Accessing a remote server via ssh Ssh into sdf.org Preview of SoC Unix environments ( stu0 )","title":"Breakout Session 8: Remote Servers (10 minutes)"},{"location":"schedule/#break-20-minutes_4","text":"","title":"Break (20 minutes)"},{"location":"schedule/#plenary-session-9-conclusion-and-the-unix-philosophy-15-minutes","text":"The Unix Philosophy Do one thing well Use simple text file Make every program a filter and make them work together Avoid unnecessary output","title":"Plenary Session 9: Conclusion and The Unix Philosophy (15 minutes)"},{"location":"shell/","text":"Terminal and Shell What is a Terminal? With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. What is a Shell? The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users.","title":"Terminal and Shell"},{"location":"shell/#terminal-and-shell","text":"","title":"Terminal and Shell"},{"location":"shell/#what-is-a-terminal","text":"With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc.","title":"What is a Terminal?"},{"location":"shell/#what-is-a-shell","text":"The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. I (Wei Tsang) personally use fish for my day-to-day work. Oh-my-zsh ( zsh ) is another shell popular among experienced users.","title":"What is a Shell?"},{"location":"tmate/","text":"Setting Up tmate Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS. What is tmate ? tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly. Installing tmate on WSL or Ubuntu Run the following in your terminal: sudo apt-get install tmate Installing tmate on macOS Run the following in your terminal: brew install tmate","title":"Setup tmate"},{"location":"tmate/#setting-up-tmate","text":"Before you continue, read about what is a terminal . Make sure you have set up apt if you use WSL and brew if you use macOS.","title":"Setting Up tmate"},{"location":"tmate/#what-is-tmate","text":"tmate is a tool that allows you to share your terminal with others. This allows another person to have enter text into your terminal and to see the output returned by your terminal. We will use tmate to allow tutors to view and type into your terminal. Giving someone else full control of your computer is dangerous -- so you need to be sure that you are sharing your terminal with someone you trust (e.g., your professor and your tutor). Do NOT share your tmate link publicly.","title":"What is tmate?"},{"location":"tmate/#installing-tmate-on-wsl-or-ubuntu","text":"Run the following in your terminal: sudo apt-get install tmate","title":"Installing tmate on WSL or Ubuntu"},{"location":"tmate/#installing-tmate-on-macos","text":"Run the following in your terminal: brew install tmate","title":"Installing tmate on macOS"},{"location":"unix/","text":"Basic UNIX Commands UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster. Connect to the Programming Environment (PE) If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assumes that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. pwd : Print Current Working directory pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it. ls : LiSt files The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command. cd : Change Directory To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return to home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$ rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/ cp : CoPy files ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory. mv : MoVe or rename files mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation. The tab key can also complete the name of command. rm : ReMove files Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While UNIX command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!) and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively ask you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you setup your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\" cat : CATenate file content to screen ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article. chmod : Changing UNIX File Permission It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwx--xrwx -rwxrwxrwx , or from -rwxr--r-- to -rwx--xr-x -rwxr-xr-x , and so on. You get the idea. Another way to change the permission is set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises. scp : Secure Copy Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well. Specifying A Path in UNIX In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any bash you like, if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Basic UNIX Commands"},{"location":"unix/#basic-unix-commands","text":"UNIX-based operating systems provide a command line to interact with the system: to create directory, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interacting with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.","title":"Basic UNIX Commands"},{"location":"unix/#connect-to-the-programming-environment-pe","text":"If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and wait for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assumes that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs into the system. The above figure shows where the home directory of user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given.","title":"Connect to the Programming Environment (PE)"},{"location":"unix/#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it.","title":"pwd: Print Current Working directory"},{"location":"unix/#ls-list-files","text":"The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first login, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as oppose to, say, printing \"This is an empty directory.\")","title":"ls: LiSt files"},{"location":"unix/#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History UNIX maintains a history of your previously executed UNIX commands, and you may use the up and down arrows to go through it. Press the up arrow until you find a previously executed UNIX command. You may then press Enter to execute it, or edit the command before executing it. This is handy when you need to repeatedly executed a long UNIX command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix/#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return to home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$","title":"cd: Change Directory"},{"location":"unix/#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/","title":"rmdir: ReMove a subDIRectory"},{"location":"unix/#cp-copy-files","text":"ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory.","title":"cp: CoPy files"},{"location":"unix/#mv-move-or-rename-files","text":"mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename up to point where you need to type in more characters for disambiguation. The tab key can also complete the name of command.","title":"mv: MoVe or rename files"},{"location":"unix/#rm-remove-files","text":"Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While UNIX command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!) and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively ask you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you setup your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\"","title":"rm: ReMove files"},{"location":"unix/#cat-catenate-file-content-to-screen","text":"ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"unix/#man-online-manual","text":"An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.","title":"man: Online MANual"},{"location":"unix/#chmod-changing-unix-file-permission","text":"It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwx--xrwx -rwxrwxrwx , or from -rwxr--r-- to -rwx--xr-x -rwxr-xr-x , and so on. You get the idea. Another way to change the permission is set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.","title":"chmod: Changing UNIX File Permission"},{"location":"unix/#scp-secure-copy","text":"Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well.","title":"scp: Secure Copy"},{"location":"unix/#specifying-a-path-in-unix","text":"In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any bash you like, if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Specifying A Path in UNIX"},{"location":"why-cli/","text":"Command-Line Interfaces What is Command-Line Interfaces? The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer. Why CLI over GUI? Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. References The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"Why CLI?"},{"location":"why-cli/#command-line-interfaces","text":"","title":"Command-Line Interfaces"},{"location":"why-cli/#what-is-command-line-interfaces","text":"The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer.","title":"What is Command-Line Interfaces?"},{"location":"why-cli/#why-cli-over-gui","text":"Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer.","title":"Why CLI over GUI?"},{"location":"why-cli/#references","text":"The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"References"},{"location":"why-unix/","text":"Unix History of Unix To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10. Why Learn Unix? There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable. Further Readings The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"Why Unix?"},{"location":"why-unix/#unix","text":"","title":"Unix"},{"location":"why-unix/#history-of-unix","text":"To understand what Unix is and to appreciate its importance, let's take a glimpse into the history book. Early computers, in the 1940s and early 1950s, do not have an operating system. Every program will have to be designed specifically for a given hardware specification and only one program can run on the computer at one time. To run a program, a user will have to carry a stack of punch cards or tapes into the computer room and load them into the computer at a scheduled time. As computers become more sophisticated and the demand to run programs on the machine increases, humans operators are hired to manage the requests to run the programs, and these human operators have to manually schedule and manage the time allocated to each program on the machine. These tasks are slowly being replaced by a layer of software that runs on the computers starting the late 1950s. Termed operating systems , this system software helps to manage \"which program runs when\", and it includes more functionalities such as resource accounting (e.g., which user used how much time on the machine) and hardware management (e.g., hide the tedious operations of interfacing with memory and storage from the programmer). One of the defining development in the 1960s is the idea of time sharing - allowing computer time to be shared by multiple users. Time-sharing is revolutionary since users no longer have to queue or schedule a slotted time to run a program on a computer. The early operating system that enables time-sharing, however, is complex, difficult to use, and bloated with features. Unix is an operating system that was developed in the late 1960s and the early 1970s around this revolution, by Dennis Ritchie and Ken Thompson from Bell Laboratories. Learning from the mistakes of the past operating systems, the duo set to develop an operating system with simplicity and elegance at the core of its design. Part of the push towards simplicity is also due to the lack of powerful computers in many places at that time -- the design constraints have lead to design decisions that favor economy. Figure: Ken thompson (sitting) and Dennis Ritchie working in front of their computer. The simplicity and elegance has propelled the popularity of the Unix operating system, leading to over 600 installations reported by 1974 3 . Closely tied to the rise of Unix is the invention of C, a programming language that Dennis Ritchie and Ken Thompson used to write Unix in. This is revolutionary by itself, as programmers can then write tools and programs in a higher level structured language, rather than in low-level assembly languages as in the operating systems before. As a result of this development, Unix is the first operating system where programmers can write and run a program on the fly in front of a terminal. This ability leads to a plethora of contributions to Unix systems, utilities, and tools in the 1970s, fueling its popularity among the developers. The ease of programming and its superiority in terms of simplicity has lead to the emergence of variants of the original Unix operating systems, developed by modifying the original Unix source code. The Berkeley Software Distribution (BSD) is among the most important ones (macOS is a descendant of BSD). Another notable descendant from the original Unix is Solaris, from Sun Microsystem (now Oracle), which the School of Computing runs on its computing server (called sunfire ). Another variant of Unix is Linux -- which interestingly is developed from scratch as a hobby initially by Linus Torvalds at the age of 21. Linux follows many of the principles of Unix but is not based on the original Unix source code. Figure: Unix and Unix-like Operating Systems. While a majority of personal computers is still running Microsoft Windows 10 (88%), a vast majority of server software is running on some flavor of Unix (>70%) 1 . Almost all mobile phones are running on a variant of Unix (iOS, Android). Among software developers, more than half (53%) uses a Unix-based OS on the primary work machines 2 . Microsoft, after years of competing with Unix-based OS, has started to embrace Unix-based systems and released the Windows Subsystems for Linux, allowing Windows users to run a sandboxed Linux subsystems within Windows. We collectively call these variants of operating systems and subsystems the Unix computing environment , which today includes all OS from Apple (macOS, iOS, etc), Linux-based systems (Ubuntu, Android, etc), commercial servers (Oracle's Solaris, HP's HP-UX, IBM's AIX), and subsystems within Microsoft Windows 10.","title":"History of Unix"},{"location":"why-unix/#why-learn-unix","text":"There are several reasons: Unix-based OS is the dominant operating system in the world, and as a computing student, you will likely have to interface with one sometime in your career. Unix design is rooted in its simplicity and economy. It is probably the most productive programming environment you can have to do most of your day-to-day tasks and to develop software as a computing professional. Unix design is also rooted in its programmability. If there is something that you wish to automate a task to improve your productivity, you can easily compose new tools from the existing ones. The Unix philosophy serves as a great example of how good software should be designed: simple, do one thing well, composable.","title":"Why Learn Unix?"},{"location":"why-unix/#further-readings","text":"The Art of Unix Programming: History of Unix , by Eric Steven Raymond Stack Overflow Developer Survey 2020 \u21a9 Usage Share of OS , by Wikipedia \u21a9 The Unix Time Sharing System , by Dennis Ritchie and Ken Thompson. \u21a9","title":"Further Readings"},{"location":"wsl/","text":"Setting Up Unix Computing Environment on Windows 10 with WSL WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1. Requirements Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely. Installing WSL 1 Step 1: Enabling WSL on Windows 10 through PowerShell Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command. Step 2: Restart your computer Step 3: Install Ubuntu After restarting your computer, go to the Microsoft Store and get Ubuntu . Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username. Launching WSL To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment. Getting ready to install tools WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt-get update What it does: apt-get is a command to install, upgrade, and uninstall software and other packages in Ubuntu. apt-get update asks apt-get to obtain the latest list of available packages from the Internet. sudo performs apt-get update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix).","title":"Setup for Windows 10"},{"location":"wsl/#setting-up-unix-computing-environment-on-windows-10-with-wsl","text":"WSL, or Windows Subsystem for Linux , is a subsystem that allows users to run a Unix computing environment within Windows 10. This is the recommended method for having a local Unix computing environment for your Windows 10 machine, for the purpose of CS1010, CS2030, CS2030S, and CS2040 in Semester 1, AY2020/21. There are two versions, WSL 1 and, a newer, WSL 2. For the Unix@Home workshop, it suffices for attendees to install WSL 1.","title":"Setting Up Unix Computing Environment on Windows 10 with WSL"},{"location":"wsl/#requirements","text":"Before you proceed with the instructions below, you need to make sure that: You have 64-bit versions of Windows 10, version 1607 or higher ( Here is how you check ); You have administrator access to your Windows 10; And You have an SoC Unix account. You can create an SoC Unix account here . For SoC students, this username is something that sticks with you for the rest of your SoC life -- so choose wisely.","title":"Requirements"},{"location":"wsl/#installing-wsl-1","text":"","title":"Installing WSL 1"},{"location":"wsl/#step-1-enabling-wsl-on-windows-10-through-powershell","text":"Before you install WSL 1, you need to first enable the \"Windows Subsystem for Linux\" feature by running the following command in PowerShell. dism . exe / online / enable-feature / featurename : Microsoft-Windows-Subsystem-Linux / all / norestart You can achieve this step by: Hit Win to open the Start menu, type PowerShell , then right-click on Windows PowerShell, and click \"Run as administrator\" Copy the command above by selecting it and then hitting Ctrl + C Go to your PowerShell window and paste the command above by hitting Ctrl + V . Press enter if needed to run the command.","title":"Step 1: Enabling WSL on Windows 10 through PowerShell"},{"location":"wsl/#step-2-restart-your-computer","text":"","title":"Step 2: Restart your computer"},{"location":"wsl/#step-3-install-ubuntu","text":"After restarting your computer, go to the Microsoft Store and get Ubuntu . Follow the on-screen instructions to install. When you are asked to create a user account and password, we suggest that you choose a Unix username that is that same as your SoC Unix username.","title":"Step 3: Install Ubuntu"},{"location":"wsl/#launching-wsl","text":"To launch WSL, you can hit Win + R and type in Ubuntu followed by Enter . This should bring up the Unix command-line interface for you to interact with the Unix computing environment.","title":"Launching WSL"},{"location":"wsl/#getting-ready-to-install-tools","text":"WSL comes with apt as the package manager, which is a convenient way to list, search, install, update, and uninstall software and libraries in WSL. After you have set up WSL, run the following: sudo apt-get update What it does: apt-get is a command to install, upgrade, and uninstall software and other packages in Ubuntu. apt-get update asks apt-get to obtain the latest list of available packages from the Internet. sudo performs apt-get update with a super-user's level permission. This command may ask you to enter your password. (Note: super-user means administrator in Unix).","title":"Getting ready to install tools"}]}